Introducing Rockstar
Rockstar is a computer programming language designed for creating programs that are also hair metal power ballads.

Here’s Fizzbuzz in Rockstar.

Midnight takes your heart and your soul
While your heart is as high as your soul
Put your heart without your soul into your heart

Give back your heart


Desire is a lovestruck ladykiller
My world is nothing 
Fire is ice
Hate is water
Until my world is Desire,
Build my world up
If Midnight taking my world, Fire is nothing and Midnight taking my world, Hate is nothing
Shout "FizzBuzz!"
Take it to the top

If Midnight taking my world, Fire is nothing
Shout "Fizz!"
Take it to the top

If Midnight taking my world, Hate is nothing
Say "Buzz!"
Take it to the top

Whisper my world
Inspired by this tweet from Paul Stovell, the Rockstar language was created by Dylan Beattie. There are multiple open source implementations, and Rockstar has been widely covered on the web, including articles on BoingBoing and in Classic Rock magazine.

bout Me
My name is Dylan Beattie. I'm a software development consultant, conference speaker and musician based in London, UK. I'm the founder and director of Ursatile, an independent consultancy specialising in software development, communications training and technology strategy.

I'm the creator of the Rockstar programming language, and I'm a Microsoft MVP for Visual Studio and Development Technologies. This blog and all content and opinions are my own.

You can follow me on Twitter, read my code on GitHub, view my profile on StackOverflow, hear my music on YouTube and see my photographs on Flickr. You can even email me at dylan@dylanbeattie.net if you really want to.

Speaker Bios
If you're looking for a speaker bio or photographs for your event website, help yourself!

The Really Short Bio
Dylan Beattie designs software, builds websites and makes music. He lives in London.

copy html copy markdown copy text50-Word Bio (271 characters)
Dylan Beattie is a consultant, software developer and international keynote speaker. He’s been building web applications since the 1990s, and works primarily on Microsoft .NET, HTTP APIs, UX design, and distributed systems.

Dylan lives and works in London and when he’s not writing code he plays guitar and writes songs.

copy html copy markdown copy text100-Word Bio (600 characters)
Dylan Beattie is a consultant, software developer and international keynote speaker. He’s has been building data-driven web applications since the 1990s; he’s managed teams, taught workshops, and worked on everything from tiny standalone websites to complex distributed systems. He’s a Microsoft MVP, and he regularly speaks at conferences and user groups all over the world.

Dylan is the creator of the Rockstar programming language, the director of Ursatile, and the founder of The Linebreakers, the world’s greatest tech comedy party rock band. He’s online at dylanbeattie.net and on Twitter as @dylanbeattie.

copy html copy markdown copy text250-Word Bio (1600 characters)
Dylan Beattie is a consultant, software developer and international keynote speaker. Dylan has been building data-driven web applications since the 1990s; he’s managed development teams, designed large-scale distributed systems, taught workshops on Microsoft .NET and HTTP API development, and presented keynote talks at software conferences on four continents.

Before founding Ursatile, Dylan was CTO at Skills Matter in London until they closed down in 2019. Prior to that he was webmaster, IT Manager, and eventually systems architect at Spotlight, where his first-hand experience of watching an organisation and its codebase evolve over more than a decade provided him with a unique insight into how everything from web standards and API design to Conway’s Law and recruitment ends up influencing a company’s code and culture.

Dylan grew up in southern Africa, moving to the UK with his family when he was nine. He’s a Microsoft MVP and holds a degree in Computer Science from the University of Southampton. He’s the creator of Rockstar, a programming language designed for creating computer programs that are also songs, and he’s performed his software-themed parodies of classic rock songs all over the world with The Linebreakers. He’s into skiing, scuba diving, Lego, cats, travel and photography. You’ll find him online at dylanbeattie.net and on Twitter as @dylanbeattie, and offline at meetups and rock bars all over the world, wearing a big black hat.

This article is not detailed enough and needs to be expanded. Please help us by adding some more information.
Rockstar is a dynamically typed Turing-complete programming language designed for creating computer programs that are also song lyrics. Rockstar is heavily influenced by the lyrical conventions of 1980s hard rock and power ballads. It was created by Dylan Beattie in 2018, inspired by a tweet suggesting that "to really confuse recruiters, someone should make a programming language called Rockstar."

Although Rockstar is a fully-specified language with multiple implementations, it was created primarily to satirise the use of the phrase 'rockstar developer' in IT job listings and recruitment - the joke being that if Rockstar is a real programming language that's easy to learn, then anybody who wants to invest a few minutes in it can legitimately call themselves a 'rockstar developer'.

Rockstar is superficially similar to the verbose English-based syntax of languages like COBOL and Visual Basic, and includes some unique language features intended to "give the programmer an unprecedented degree of poetic license when it comes to the composition and structure of their programs."


Contents
1	Examples
1.1	Hello, World!
1.2	Truth-machine
1.3	FizzBuzz
1.4	Project Euler
2	External resources
2.1	Project Pages
2.2	Implementations
2.3	Social Spaces
2.4	Conference
2.5	Media Coverage
Examples
Hello, World!
Say "Hello World"
(If you can write this, you are a qualified rockstar developer. Congratulations.)

Truth-machine
Listen to the box
If the box is gone
Say the box.
Else
While the box is not gone.
Say the box.
FizzBuzz
 Midnight takes your heart and your soul
 While your heart is as high as your soul
 Put your heart without your soul into your heart
 
 Give back your heart
 
 
 Desire is a lovestruck ladykiller
 My world is nothing 
 Fire is ice
 Hate is water
 Until my world is Desire,
 Build my world up
 If Midnight taking my world, Fire is nothing and Midnight taking my world, Hate is nothing
 Shout "FizzBuzz!"
 Take it to the top
 
 If Midnight taking my world, Fire is nothing
 Shout "Fizz!"
 Take it to the top
 
 If Midnight taking my world, Hate is nothing
 Say "Buzz!"
 Take it to the top
   
 Whisper my world
Project Euler
Code for Problem 2: Please note that there are two blank lines before the last line

Henry is gone.
Jack is harkworking.
Jill is gone.
While Jack is lower than 4000000
Let Jill be with Jack.
Let Jack be with Jill.
Let Jill be Jack without Jill.
Let Jack be without Jill.
Let Papa be Jack over 2.
Turn it down.
Let Papa be of 2.
If Papa is Jack
Let Henry be with Jack.


Say Henry.
Code for Problem 6:

Jesus is a scratching rockplayer.
Henry is gone.
While Jesus isn't nothing
Let Es be Jesus without 1.
Let El be Jesus of Jesus of Es.
Let Henry be with El.
Knock Jesus down.

Say Henry.
External resources
Project Pages
codewithrockstar.com is the official site, including an online Rockstar interpreter
The Rockstar programming language on GitHub
Implementations
Satriani is the official reference implementation of Rockstar, written in JavaScript with peg.js
Rocky is a a fully-compliant Rockstar interpreter in Java, including a REPL mode, a CLI debugger, and the option to use DEC64 numbers (as per the original Rockstar draft spec) instead of IEEE754.
rockstar-js - Rockstar-to-JavaScript transpiler
rockstar-lexer - Rockstar lexer written in Haskell with Alex
rockstar-java - Rockstar interpreter in Java
rockstar-ml - Rockstar interpreter in OCaml
rockstar-py - Rockstar-to-Python transpiler
kaiser-ruby - Rockstar to Ruby transpiler
sublime-rockstar-syntax - Syntax highlighter for Sublime Text 3
language-rockstar - Syntax highlighter for Atom
maiden - Rockstar interpreter in Rust (online version using WebAssembly)
Online Rockstar Parser and Transpiler: rockstar-webpiler source code online version
vim-rockstar - Syntax highlighting for vim
vscode-rockstar-language - Syntax highlighting for VSCode
sellout - Rockstar to C# (dotnet core) transpiler
Social Spaces
/r/RockstarDevs - Subreddit
Rockstar Developers - Discord Group
Conference
The Art of Code, an NDC conference
Media Coverage
Meet the boffin behind a computer programming language based on power ballads in Classic Rock magazine.
Rockstar article on BoingBoing
Rockstar on HackerNews
Rockstar on /r/ProgrammerHumor
Rockstar on dice.com
The Rockstar Programming Language | Mitigated Frenzy - see also their solution to the Rainfall problem
Proof by Induction - Rockstar usage in MIT mystery hunt on devjoe



Rockstar Tutorial
Getting Started
Tutorial
If you’re just getting started with Rockstar, the Rockstar Tutorial will walk you through the basics and have you up and rocking in no time.

“Hello, World”
“Hello World” in Rockstar looks like this:
Example Input:
```
print "hello world" (prints: hello world)
```
Example Output:
```
hello world
```

Printing things isn’t very rock‘n’roll, though. Rockers don’t print, they scream, shout, whisper or maybe just say things, so these are all valid aliases for print:
Example Input:
```
Scream "Hello Cleveland!" (prints: Hello Cleveland!)
Say "All I wanna know is..." (prints: All I wanna know is...)
Shout "Are you ready to rock?" (prints: Are you ready to rock?)
```
Example Output:
```
Hello Cleveland!
All I wanna know is...
Are you ready to rock?
```

print adds a newline to the end of the output. If you don’t want this, use write:
Example Input:
```
Write 1. Write 2; write 3!
(writes: 123)

Write "A dream "
Print "of dolphins"
(prints: A dream of dolphins)
```
Example Output:
```
123A dream of dolphins
```

Almost everything in Rockstar is case-insensitive, and most whitespace is ignored:
Example Input:
```
  scream "hey!"
```
Example Output:
```
hey!
```

Rockstar statements end with a newline, or with any of the punctuation characters .?!;
Example Input:
```
Say 1. Say 2? Say 3! Say 4; say 5...
(prints: 1
2
3
4
5)
```
Example Output:
```
1
2
3
4
5
```
Command line parameters
If you’re running Rockstar from the command line, you can pass parameters to your Rockstar program. Parameters beginning - or -- are for the Rockstar interpreter itself:

Argument	Effect
--version	Display the Rockstar version number and exit.
All subsequent parameters will be passed to your Rockstar program, where you can access them in a global array called arguments, or its aliases the outside or the world:

Comments
The use of comments in Rockstar programs is strongly discouraged: this is rock’n’roll; it’s up to the audience to find their own meaning. If you absolutely insist on commenting your Rockstar programs, comments should be contained in parentheses (). Yes, this means you can’t use brackets in arithmetic expressions and may need to decompose complex expressions into multiple evaluations and assignments.
Example Input:
```
(This is a Rockstar comment)

(Rockstar supports nested comments (like this (see?)))

Shout (as loud as you can (like, REALLY loud!)) "nested comments are cool!"

(prints: nested comments are cool!)

Shout "Comments inside strings (like this (see?)) aren't comments"
(prints: Comments inside strings (like this (see?)) aren't comments)
```
Example Output:
```
nested comments are cool!
Comments inside strings (like this (see?)) aren't comments
```

Line comments
You can also use the # character to indicate a comment. Line comments last until the end of the line.

The only reason I did this is that one of you lot might actually be unhinged enough that you want to put a #!/bin/rockstar at the start of their Rockstar programs so you can run them straight from your terminal… and as much as that’s a terrible idea, I’m not going to stop you.

ChordPro comments
Since Rockstar programs are song lyrics, it stands to reason you might want to include the chords for your programs, so aspiring rockstar developers can play along at home, so Rockstar also allows comments to be surrounded by { } and [ ]
Example Input:
```
#!/bin/rockstar

{title: The Rockstar Blues}
{artist: Dylan Beattie}
{tempo: 120bpm}

{start_of_verse}
[A] Say "it's one for the money"
[A] Say "it's two for the show"
[D] Say "three to get ready"
[A] Say "now go go go"
{end_of_verse}

{start_of_chorus}
[D] Say 5? [D] Say 6? [A] Say 7? [A] Say 8!
[E] Say 9; [D] Say 10!
[A] Say 11
Say "and that's the Rockstar 12 bar blues"
{end_of_chorus}
```
Example Output:
Running this program through the ChordPro system produces chords

Types and Values
Types
Rockstar uses a similar type system to that defined by the ECMAScript type system, except undefined doesn’t sound very rock’n’roll so we use mysterious instead.

Number - Numbers in Rockstar are fixed-precision , stored according to the IEEE 754 standard. (An earlier version of this spec proposed that Rockstar used the DEC64 numeric type. This is a perfect example of something that seemed like a great idea after a couple of beers but turns out to be prohibitively difficult to implement…)
Boolean - a logical entity having two values true and false.
right, yes and ok are valid aliases for true
wrong, no and lies are valid aliases for false
Function - used for functions.
Null - the null type. Evaluates as equal to zero and equal to false. The keywords nothing, nowhere, nobody, and gone are defined as aliases for null
Mysterious - the value of any variable that hasn’t been assigned a value, denoted by the keyword mysterious.
Strings
Rockstar strings are surrounded by double quotes. A string literal includes everything up to the closing quote, including newlines. To include a double quote in a string, use a pair of double quotes. Rockstar strings are stored internally as UTF-16, and support the full Unicode character set.

The keywords empty, silent, and silence are aliases for the empty string ("")
Example Input
```
Print "this is a string literal"

Print "This string includes ""quotes"""

Print "This string
contains
line
breaks"

Print "Стріляй!
Скажи, чому боїшся ти
Зробити цей останній крок?"

Print "🎸✨🎆💔🌃🐍💘🌾🍾"

Print empty

Print silence
```
Example Output:
this is a string literal
This string includes "quotes"
This string
contains
line
breaks
Стріляй!
Скажи, чому боїшся ти
Зробити цей останній крок?
🎸✨🎆💔🌃🐍💘🌾🍾
```

Numbers
Number literals are written as ordinary digits; decimals and negative numbers are supported:
Example Input:
```
Print 1 (prints: 1)
Print 0.5 (prints: 0.5)
Print +8 (prints: 8)
Print -10 (prints: -10)
Print -.4 (prints: -0.4)
Print 1.000000000 (prints: 1)
Print 1.2. (prints: 1.2)
```
Example Output:
```
1
0.5
8
-10
-0.4
1
1.2
```

A Rockstar number is a 128-bit fixed-precision decimal, between -79,228,162,514,264,337,593,543,950,335 and +79,228,162,514,264,337,593,543,950,335.

You get 29 digits, a minus sign if you need it, and a a decimal point you can put anywhere you like:
Example Input:
```
Print   +79228162514264337593543950335
(prints: 79228162514264337593543950335)
Print    -79228162514264337593543950335
(prints: -79228162514264337593543950335)

Print   +0.0000000000000000000000000001
(prints: 0.0000000000000000000000000001)
Print     -.0000000000000000000000000001
(prints: -0.0000000000000000000000000001)

Print   +10000000000000.000000000000001
(prints: 10000000000000.000000000000001)
Print    -10000000000000.000000000000001
(prints: -10000000000000.000000000000001)
```
Example Output:
```
79228162514264337593543950335
-79228162514264337593543950335
0.0000000000000000000000000001
-0.0000000000000000000000000001
10000000000000.000000000000001
-10000000000000.000000000000001
```

Numbers with more than 29 digits will be rounded to 29 digits if they have a decimal part:
```
Print   +1000000000000000.00000000000001
(prints: 1000000000000000)
Print    -1000000000000000.00000000000001
(prints: -1000000000000000)

Print   +79228162514264337593543950335.1
(prints: 79228162514264337593543950335)
Print    -79228162514264337593543950335.1
(prints: -79228162514264337593543950335)

Print +0.00000000000000000000000000001 (prints: 0)
Print -0.00000000000000000000000000001 (prints: 0)
```
Example Output:
```
1000000000000000
-1000000000000000
79228162514264337593543950335
-79228162514264337593543950335
0
0
```

Booleans
Rockstar supports the Boolean literals true (aliases: yes, ok, right) and false (aliases: no, wrong, lies).
Example Input
```
Print true (prints: true)
Say OK (prints: true)
Scream yes (prints: true)
Shout right (prints: true)
 
Print false (prints: false)
Say no (prints: false)
Shout wrong (prints: false)
Scream lies (prints: false)
```
Example Output:
```
true
true
true
true
false
false
false
false
```

Null
Rockstar null represents an expression which has no meaningful value. Aliases for null are nothing, nowhere, nobody and gone:
Example Input:
```
Print null (prints: null)
Say nothing (prints: null)
Scream nowhere (prints: null)
Shout nobody (prints: null)
Say gone (prints: null)
```
Example Output:
```
null
null
null
null
null
```

Variables
Rockstar variables are dynamically typed. There are three different ways to assign a variable in Rockstar.

<variable> is <expression>. Valid aliases for is are are, am, was, were, and the contractions 's and 're
put <expression> into <variable>
let <variable> be <expression>
Example Input
```
x is 1. Print x (prints: 1)
Y was 2. Print y (prints: 2)
z is -1. Print z (prints: -1)
The limit's 55. Print the limit. (prints: 55)

Put 12 into a variable. Print a variable. (prints: 12)
Let my variable be 34. Print my variable (prints: 34)

Put nothing into the fire. Print the fire. (prints: null)
Let the fire be silence. Print the fire. (prints: )
```
Example Output
```
1
2
-1
55
12
34
null
```
Rockstar variables are function scoped - see variable scope in the section on functions for more about how this work.

Variable names in Rockstar
Rockstar supports three different kinds of variable names.

Simple variables can be any valid identifier that isn’t a reserved keyword. A simple variable name must contain only letters, and cannot contain spaces. Note that Rockstar does not allow numbers or underscores in variable names - remember the golden rule of Rockstar syntax: if you can’t sing it, you can’t have it. Simple variables are case-insensitive.
Example Input
```
x is 2
pi is 3.14159
greeting is "hello world"

say x (prints: 2)
say pi (prints: 3.14159)
say greeting (prints: hello world)
```
Example Output:
```
2
3.14159
hello world
```

Common variables consist of one of the keywords a, an, the, my, your or our followed by whitespace and an identifier. The keyword is part of the variable name, so a boy is a different variable from the boy. Common variables are case-insensitive.

Common variables can include language keywords, so you can have variables called your scream, my null, the silence.
Example Input:
```
The greeting is "hello world"
SHOUT THE GREETING (prints: hello world)

A number is 12
Our flag is "death"
print a number (prints: 12)
print our flag (prints: death)

The variable is 1
my variable is 2
Your variable is 3
Say the variable (prints: 1)
Say my variable (prints: 2)
Say your variable (prints: 3)

The silence is nothing
Scream the silence (prints: null)
Your scream is "aargh!"
Scream your scream (prints: aargh!)
```
Example Output:
```
hello world
12
death
1
2
3
null
aargh!
```

Proper variables are multi-word proper nouns: words which aren’t language keywords, each starting with an uppercase letter, separated by spaces. (Single-word variables are always simple variables.) Whilst some developers may use this feature to create variables with names like Customer ID, Tax Rate or Distance In Kilometres, we recommend you favour idiomatic variable names such as Doctor Feelgood, Mister Crowley, Tom Sawyer, and Billie Jean.

A note on case sensitivity in Rockstar
Rockstar keywords and variable names are all case-insensitive, with the exception of proper variables. Proper variables are case-insensitive apart from the first letter of each word, which must be a capital letter.

TIME, time, tIMe, TIMe are all equivalent. Simple variables are case-insensitive.
MY HEART, my heart, My Heart - are all equivalent; the keyword my triggers common variable behaviour
Tom Sawyer, TOM SAWYER, TOm SAWyer - are all equivalent; the capital S on Sawyer triggers proper variable behaviour
DOCTOR feelgood is not a valid Rockstar variable; the lowercase f on feelgood does not match any valid variable naming style and so the variable name is not valid.

Pronouns
As well as referring to variables by name, you can refer to them using pronouns. The keywords it, he, she, him, her, they, them, ze, hir, zie, zir, xe, xem, ve, and ver refer to the current pronoun subject.

The pronoun subject is updated when:

A variable is declared or assigned:

My heart is true. Say it - it here refers to my heart

A variable is the left-hand side of a comparison used as the condition in an if, while or until statement

If my heart is true, give it back, yeah - it refers to my heart
Example Input:
```
The number is 1. Shout it (prints: 1)
It is 2. Shout it (prints: 2)
The string is "hello". Print it (prints: hello)
It is "world". Print it (prints: world)
Print the number (prints: 2)
Print the string (prints: world)

Doctor Feelgood is right. Scream Doctor Feelgood (prints: true)
He is wrong. Scream Doctor Feelgood (prints: false)

The Darkness are 1. Shout the darkness (prints: 1)
They are 2. Shout them (prints: 2)

Alpha is 1
Beta is 2
If alpha is 1 print it (prints: 1)

Gamma is 3
Delta is 4
While gamma ain't nothing, write it. Knock it down, yeah. (writes: 321)
```
Example Output:
```
1
2
hello
world
2
world
true
false
1
2
1
321
```

The Thing About “Her”
her is where Rockstar runs smack into one of the English language’s most delightful idiosyncrasies, because the feminine third person pronoun and the feminine possessive are the same word.

Give him his guitar. Give them their horns. Give her her bass

There is therefore a very specific restriction in the Rockstar grammar: you can’t use her as a common variable prefix if the second part of the variable is a keyword.

You can have variables called the times, your lies, my right, even though times, lies and right are language keywords, but you can’t have her times or her lies because they’d create ambiguous expressions:
```
A girl is 123
Her times are trying
Say her
Say her times 456
```

Poetic Literals
One of Rockstar’s unique features is the ability to initialise variables using song lyrics.

Poetic Numbers
A poetic number begins with the like or so keyword, followed by a series of words. The Rockstar parser takes the length of each word and interprets it as a decimal digit:
Example Input:
```
Shout like a big bad monster (prints: 1337)
Scream like a banshee (prints: 17)

Papa was like a rolling stone. Shout Papa. (prints: 175)

the fire is like a shadow, the stars are like the rain
Shout the fire (prints: 16353434)

My dreams are so dark
Scream my dreams (prints: 4)
```
Example Output:
```
1337
17
175
16353434
4
```

Words of 10 or more letters are counted modulo 10, so you can use 10-letter words for 0, 11 letters for 1 and 12 letters for 2. Hyphens - are counted as letters, so demon-haunted is treated as a 12-letter word. Apostrophes are not counted, so nothing counts as 7 but nothin' counts as 6. A poetic number counts every word until the end of the current statement (indicated by a newline or punctuation .!?;) If you need a poetic number with a decimal point, use an ellipsis ... or the Unicode equivalent U+2026 … as the decimal.
Example Input:
```
Tommy's like a panther, he ain't talkin' 'bout love. Shout Tommy. (prints: 1724644)
He's like a wild animal.
Shout Tommy (prints: 146)

My heart was like ice... a life unfulfilled, wakin' everybody up, taking booze and pills.
Say it. (prints: 3.1415926535)

e is like my… darkest nightmarish longings, my cravings, a symphony of suff'ring that lasts life-long.
Say it. (prints: 2.718281828459)

Carrie's like a wolf. Danny's like a child. Print Carrie. (prints: 14)
Print Danny. (prints: 15)
```
Example Output:
```
1724644
146
3.1415926535
2.718281828459
14
15
```

Poetic strings
You can initialise string variables without quotes by using the says or said keyword. This will skip exactly one space character and then capture the rest of the line as a literal string. If the character immediately following the says keyword is not a space, it will be included in the string literal.
Example Input:
```
Tommy says we've got to hold on to what we've got.
Gina says it doesn't make a difference if we make it or not.

Print Tommy (prints: we've got to hold on to what we've got.)
Print Gina (prints: it doesn't make a difference if we make it or not.)

A variable says, I start with a comma.
Print a variable(prints: , I start with a comma.)

A variable says: I start with punctuation.
Print a variable (prints: : I start with punctuation.)

My string said it had "quotes", 'quotes', українська, עִבְרִית, 🎸✨🎆	and	tabs
Print my string (prints: it had "quotes", 'quotes', українська, עִבְרִית, 🎸✨🎆
```
Example Output:
```
we've got to hold on to what we've got.
it doesn't make a difference if we make it or not.
, I start with a comma.
: I start with punctuation.
it had "quotes", 'quotes', українська, עִבְרִית, 🎸✨🎆	and	tabs
```

Ninja Strings
Ninja strings are another unique feature of Rockstar, designed to let you hide strings inside the lyrics of your Rockstar programs. Using the rock keyword - which we’ll learn more about in the chapter on arrays - you can append characters to the end of a string by providing their Unicode code point - and, combined with the like keyword, you can provide that code point as a poetic number:
Example Input:
```
A string is "A"
Rock it with 67
Rock it 47, 68
Rock it like raging thunder

Shout it (prints: AC/DC)
```
Example Output
```
AC/DC
```

You can initialise a ninja string using the hold or holds keyword. The left-hand argument is the name of the variable you’re initialised, the right-hand side is the poetic number containing the code point of the character:
Example Input:
```
My dreams hold diamond nightmares
Salvation is the sea
My screams hold silent echoes
Your love is meaningless to me

Rock my dreams like a razorblade smile
Rock my dreams with your love, your love
Rock my screams like a heartbroken missile
Rock my screams with your love, your love.

My dreams are with my screams
Rock my dreams with salvation
Whisper my dreams
```
Example Output:
```
FizzBuzz!
```
Arithmetic
Expressions
Rockstar expressions are heavily inspired by JavaScript, in that they will almost always return something rather than failing.

Basic Arithmetic
Rockstar supports the standard infix arithmetic operators +, -, *, /, with several aliases for each operator so you can write lyrically pleasing expressions:

Operation	Operator	Aliases
Addition	+	with, plus
Subtraction	-	minus, without
Multiplication	*	times, of
Division	/	over, between
Example Input
```
The moon is like a kaleidoscope, out over quiet winter wonderland
The river is like a razorblade
Let my loneliness be the moon over the river
Shout my loneliness (prints: 123456)

A dream says tomorrow
A girl says no 
My heart is empty
Let it be a girl with a dream
Shout my heart (prints: no tomorrow)

The wings are like a heartbreak
the fire is like a tomb
Let the silence be the wings of the fire
Scream the silence (prints: 140)
```
Example Output:
```
123456
no tomorrow
140
```

Operator precedence obeys the convention of multiplication, division, addition, subtraction.

Rockstar doesn’t support parentheses in expressions. If the default operator precedence doesn’t do what you need, you’ll have to decompose your expression into multiple evaluations and assignments.
Example Input:
```
x is 5. y is 2. z is 4.

Print x * y (prints: 10)
Print x / y (prints: 2.5)
Print x + y (prints: 7)
Print x - y (prints: 3)

Print 1 + 5 / 2 (prints: 3.5)
Print 1 + 2 * 3 (prints: 7)
Print 3 - 2 - 1 (prints: 0)
Print 1 + 2 * 3 / 4 - 5 + 6 * 7 / 8 - 9 (prints: -6.25)
```
Example Output:
```
10
2.5
7
3
3.5
7
0
-6.25
```

Here’s how Rockstar operators are defined for various combinations of types.

As a rough rule, operations involving numbers will return numbers. For arithmetic purposes, true is 1, null and false are 0. Operations involving strings will generally return strings. Any operation involving mysterious will always return mysterious.

Addition
Addition adds numbers and concatenates strings.
Example Input:
```
print 1 + 2 (prints: 3)
print 1 + "2" (prints: 12)
print 1 + true (prints: 2)
print 1 + false (prints: 1)

print "2" + 1 (prints: 21)
print "hello" + "world" (prints: helloworld)
print "hello" + true (prints: hellotrue)
print "hello" + null (prints: hellonull)

print true + true (prints: 2)
print true + 1 (prints: 2)
print true + "hello" (prints: truehello)
print true + null (prints: 1)

print null + null (prints: 0)
print null + true (prints: 1)
print null + "hello" (prints: nullhello)
print null + 1 (prints: 1)
```
Example Output
```
3
12
2
1
21
helloworld
hellotrue
hellonull
2
2
truehello
1
0
1
nullhello
1
```

Subtraction
If both operands have a numeric value, subtraction is numeric. If either or both operands is a string, Rockstar will “subtract” strings by removing the the bit you’re taking away (the subtrahend, if you want to get technical) from the bit you’re taking it away from (the minuend). Most of the time, this has no effect and subtraction just returns the string representation of the left-hand argument, but hey – you’re the one trying to subtract strings here; let’s not make out like I’m the one who has a problem.
Example Input:
```
print 1 + 2 (prints: 3)
print 1 + "2" (prints: 12)
print 1 + true (prints: 2)
print 1 + false (prints: 1)

print "2" + 1 (prints: 21)
print "hello" + "world" (prints: helloworld)
print "hello" + true (prints: hellotrue)
print "hello" + null (prints: hellonull)

print true + true (prints: 2)
print true + 1 (prints: 2)
print true + "hello" (prints: truehello)
print true + null (prints: 1)

print null + null (prints: 0)
print null + true (prints: 1)
print null + "hello" (prints: nullhello)
print null + 1 (prints: 1)
```
Example Output:
```
3
12
2
1
21
helloworld
hellotrue
hellonull
2
2
truehello
1
0
1
nullhello
1
```

Multiplication
Rockstar lets you multiply strings. Multiplying by positive integers will repeat the string. Multiply by -1 to reverse the string, multiplying by decimal fractions will extract substrings. You’ll figure it out.
Example Input:
```
print 2 * 2 (prints: 4)
print 2 * "rock" (prints: rockrock)
print 2 * true (prints: 2)
print 2 * false (prints: 0)

print "rock" * 2 (prints: rockrock)
print "rock" * 0 (prints: )
print "rock" * -1 (prints: kcor)
print "rock" * -2 (prints: kcorkcor)
print "rock" * 1.5 (prints: rockro)
print "rock" * -0.2 (prints: k)

print true * true (prints: 1)
print true * 1 (prints: 1)
print true * "hello" (prints: hello)
print false * "hello" (prints: )
print true * null (prints: 0)

print null * null (prints: 0)
print null * true (prints: 0)
print null * "hello" (prints: )
print null * 1 (prints: 0)
```
Example Output:
```
4
rockrock
2
0
rockrock

kcor
kcorkcor
rockro
k
1
1
hello

0
0
0

0
```

Division
You know where this is going now. Numbers divided by numbers give you numbers, and yes, you can divide strings. A string divided by 2 gives you the first half. A string divided by half will be repeated. A string divided by -1 will reverse.

Dividing anything by a string will tell you how many times the second string occurs in the string representation of the first operand. Dividing haystack / needle will be zero if it didn’t find needle in haystack, and positive if it found it.

Or, y’know, you can just stick to dividing numbers.
Example Input:
```
print 2 / 2 (prints: 1)
print 2 / "rock" (prints: 0)
print 2 / true (prints: 2)

print "rock" / 2 (prints: ro)
print "12345" / 5 (prints: 1)
print "haystack" / -1 (prints: kcatsyah)
print "helloworld" / -2 (prints: dlrow)
print "haystack haystack needle haystack" / "haystack" (prints: 3)
print "haystack haystack needle haystack" / "needle" (prints: 1)
print "haystack haystack needle haystack" / "banana" (prints: 0)

print true / true (prints: 1)
print true / 1 (prints: 1)
print true / "hello" (prints: 0)
print true / "e" (prints: 1)
print false / "alse" (prints: 1)

print null / true (prints: 0)
print null / "hello" (prints: 0)
print null / 1 (prints: 0)
```
Example Output:
```
1
0
2
ro
1
kcatsyah
dlrow
3
1
0
1
1
0
1
1
0
0
0
```

Compound Expressions
Languages like C support shorthand expressions like x++, x += 2, and so on.

The equivalent in Rockstar looks like this:
Example Input:
```
X is 1
X is with 2
Print X (prints: 3)

Y is 5
It is without 3
Print it. (prints: 2)

Z is 100
It is over 5, 4, & 2
Shout it (prints: 2.5)
```
Example Output:
```
3
2
2.5
```

Binary Logic
Truthiness
Every possible value in Rockstar evaluates to either true or false – this is known as truthiness. The only things in Rockstar which are falsy are:

false
null
mysterious
the empty string ""
the number 0
Everything else is truthy, which means if you put in in a Boolean context (such as the condition of an if statement) it’ll be ‘true’.

Unary Not
Unary not in Rockstar uses the keywords not and non-:
Example Input:
```
Print not true (prints: false)
Print not false (prints: true)

Print non-true (prints: false)
Print non-non-non-non-non true (prints: false)

Print not 0 (prints: true)
Print not 1 (prints: false)
Print not "" (prints: true)
Print not "false" (prints: false)

Heinous is wrong!
Say Heinous (prints: false)
Bill is non heinous! Say Bill (prints: true)
Bill is non-non heinous! Say Bill (prints: false)
Bill is non-non-NON heinous! Say Bill (prints: true)
```
Example Output:
```
false
true
false
false
true
false
true
false
false
true
false
true
```

Binary Logic
Rockstar supports binary logic expressions using the keywords and, or, and nor.
Example Input:
```
Print false nor false (prints: true)
Print true nor false (prints: false)
Print false nor true (prints: false)
Print true nor true (prints: false)

Print true and true (prints: true)
Print true and false (prints: false)
Print false and true (prints: false)
Print false and false (prints: false)

Print true or true (prints: true)
Print true or false (prints: true)
Print false or true (prints: true)
Print false or false (prints: false)

Print true and not true (prints: false)
Print true and not false (prints: true)
Print false or not true (prints: false)
Print false or not false (prints: true)
```
Example Output:
```
true
false
false
false
true
false
false
false
true
true
true
false
false
true
false
true
```

not has the highest precedence, then and, then or, then nor:
Example Input:
```
Print not true and true (prints: false)
Print not true or true (prints: true)
Print not false and false (prints: false)
Print not false or false (prints: true)

Print true and true or false (prints: true)
Print false and true or false (prints: false)
Print false and false or true (prints: true)
Print true or true and false (prints: true)

Print false nor false or false (prints: true)
Print false or false nor false (prints: true)
Print false nor false or true (prints: true)
Print true nor true or true (prints: true)
print true nor true and false (prints: false)
```
Example Output:
```
false
true
false
true
true
false
true
true
true
true
true
true
false
```

Binary Logic for Non-Boolean Types
Binary logic applied to strings and numbers in Rockstar doesn’t necessarily return a Boolean result: it returns whichever of the operands resolves the logical constraint of the expression:#
Example Input:
```
Print "one" or "two" (prints: one)
Print "hello" and 0 (prints: 0)
Print "foo" and "bar" (prints: bar)

Print false or "rock!" (prints: rock!)
Print 0 or null (prints: null)
Print true and "rock!" (prints: rock!)
```
Example Output:
```
one
0
bar
rock!
null
rock!
```

The and and or operators in Rockstar will short-circuit:

X or Y: evaluate X. If the result is truthy, return it, otherwise evaluate Y and return that.
If X is truthy, Y is never evaluated.
X and Y: evaluate X. If the result is falsy, return it, otherwise evaluate Y and return that.
If X is falsy, Y is never evaluated.
In the following examples, short-circuiting means the division by zero is never evaluated:
Example Input:
```
Print true or 1/0 (prints: true)
Print false and 1/0 (prints: false)
Print true nor 1/0 (prints: false)
```
Example Output:
```
true
false
false
```

Equality and Comparison
Equality in Rockstar uses the is, was, are and were keywords. Equality is determined as follows:

If one operand is a Boolean, compare it to the truthiness of the other operand:
All non-zero numbers and non-empty strings are equal to true
Otherwise, if one operand is a string, compare it with the string representation of the other argument *
Otherwise, the values of the two operands are compared.
Example Input:
```
Print 1 is 1 (prints: true)

Your memories are 1. My dreams are 1.
Say your memories are my dreams (prints: true)
It's with 3.
Say your memories are my dreams (prints: false)

Print "rock" is "roll" (prints: false)

Print 0 is true (prints: false)
Print 0 is false (prints: true)
Print 1 is true (prints: true)
Print 2 is true (prints: true)

Print 123 is "123" (prints: true)
Print "yeah!" is true (prints: true)
```
Example Output:
```
true
true
false
false
false
true
true
true
true
true
```

Inequality
Inequality uses the isn't and ain't keywords.

Watch out for is not: not is the unary negation operator, so a is not b will work as expected when b is a Boolean, but when b is a number or a string, it’ll compare a with the logical not of the truthiness of b
Example Input:
```
Print 1 ain't 1 (prints: false)
Print 1 isn't 2 (prints: true)
Print 1 ain't 2 (prints: true)

Print false is not true (prints: true)
Print 1 is not 2 (prints: false)

Print "rock" ain't "roll" (prints: true)

Print 123 ain't "123" (prints: false)
Print "yeah!" is true (prints: true)
```
Example Output:
```
false
true
true
true
false
true
false
true
```

Identity
To compare values without performing any type coercion, use the exactly keyword, or its aliases really, actually or totally:
Example Input:
```
Print 1 is 1 (prints: true)
Print 1 is "1" (prints: true)
Print 1 is totally "1" (prints: false)

Print "true" is true (prints: true)
Print "true" is totally true (prints: false)
Print 1 + 1 is totally 2 (prints: true)

Print 1 - 1 is false (prints: true)
Print 1 - 1 is really false (prints: false)

Print 1 + 2 is "3" (prints: true)
Print 1 + 2 is exactly "3" (prints: false)

Heinous is wrong
Bill is right
Say Bill is totally non-non-non-non-NON heinous (prints: true)
```
Example Output:
```
true
true
false
true
false
true
true
false
true
false
true
```

Comparison
Rockstar supports the following comparison operators:

is higher/greater/bigger/stronger than to denote ‘greater than’
is lower/less/smaller/weaker than to denote ‘less than’
is as high/great/big/strong as to denote ‘greater than or equal to’
is as low/little/small/weak as to denote ‘less than or equal to’
By default, comparison use type coercion:

If either operand is a string, it’s compared to the string representation of the other value
This means that 10 < "2", because 10 is coerced to the string 10, which is alphanumerically less than the string 2
Otherwise, the numeric values of the operands are compared (true is 1, null and false are 0)
Example Input:
```
Say "a" is greater than "b" (prints: false)

Say "a" is greater than true (prints: false)
Say "z" is greater than true (prints: true)

Say true is greater than "a" (prints: true)
Say true is greater than "z" (prints: false)

Say "123" is greater than 456 (prints: false)
Say "789" is greater than 456 (prints: true)

Say "2" is greater than 10 (prints: true)
Say 10 is greater than "2" (prints: false)

Say 1 is as great as "1" (prints: true)
Say 1 is as great as 2 (prints: false)
```
Example Output:
```
false
false
true
true
false
false
true
true
false
true
false
```

Expression Lists
Expression lists
There are many places in Rockstar where you can provide a list in place of an expression… and if you can have a list of expressions, and an expression can be a list, things get all wibbly-wobbly and you can go all cross-eyed.
Example Input:
```
Rock my world
Rock my world with "a" + "b", "c", and "d" + "e" , "f", and "g" + "h" 'n' "i"
Join my world with "-"
Shout my world
(prints: abc-def-ghi)


Reverse takes a string giving -1 times a string

X is "The number "
Y is " si tsaeB eht "
X is with "of", and true and reverse taking Y
The number is 600 with 60 & 6
X is with the number
Shout X (prints: The number of the Beast is 666)
```
Example Output:
```
abc-def-ghi
The number of the Beast is 666
```

Let’s start with the easy one: a variable list

Variable lists are used to declare the arguments to a function. They can only contain variable names, and variables must be separated by one of:

A comma ,
An ampersand &
The keyword and
The Oxford comma , and
A nacton
Nacton (n.) The ‘n’ with which cheap advertising copywriters replace the word ‘and’ (as in ‘fish ‘n’ chips’, ‘mix ‘n’ match’, ‘assault ‘n’ battery’), in the mistaken belief that this is in some way chummy or endearing.

- "The Meaning of Liff", Douglas Adams & John Lloyd

Rockstar supports both the UK nacton 'n' (as in fish ‘n’ chips) and the US nacton n' (as in Guns n’ Roses.)
Example Input:
```
Sum takes x, y, z giving x + y + z

Product takes x & y giving x * y

My Michelle takes Axl and Slash, Duff & Izzy, and Steven
Shout Axl. Shout Slash. Shout Duff! Shout Izzy
Shout Steven, yeah.

Jungle Love takes Prince, Morris Day and the Time
Shout Prince with Morris Day & the Time, Morris Day & the Time, oh

Shout sum taking 1, 2, 3
Whisper product taking 5, 6
Call my Michelle with "A", "B", "C", "D", and "E"
Call Jungle Love with "oh", "-we", "-oh"
```
Example Output:
```
6
30
A
B
C
D
E
oh-we-oh-we-oh
```

Then there’s an primary list, used to provide arguments to a function. The elements in a primary list must be primaries, and you can’t separate a primary list with an Oxford comma - if the parser sees , and, that means the primary list is finished and move on to the next thing.
Example Input:
```
The jungle takes Axl and Slash, Duff & Izzy, and Steven
Shout Axl! Shout Slash! Shout Duff! Shout Izzy! Shout Steven, yeah!

Add takes x and y giving x + y

The city is dark
the fire is on fire

Add taking 3 & 4

Call the jungle with 1, 2, 3 & 4 'n' 5
The jungle taking "Guns" 'n' "and" & " n'" & "and" & "Roses"
```
Example Output:
```
1
2
3
4
5
Guns
and
 n'
and
Roses
```

Rockstar grammar supports three different kinds of lists:

Expression lists
Variable lists
Primary lists
Foo is 1 with 2 + 3, 4, 5 and 6, bar taking 7, 8 and 9, 10, “yeah”

First, 8 and 9 cannot be a function argument (functions only accept primaries), so bar taking 7 is an expression:

Foo is 1 with 2 + 3, 4, 5 and 6, (bar taking 7), 8 and 9, 10, “yeah”

Second, ` and ` (with no leading comma) is always the logical-and operator, and the right-hand operand in a logic expression can’t be a list:

Foo is 1 with 2 + 3, 4, (5 and 6), (bar taking 7), (8 and 9), 10, “yeah”

So now we propagate the + operator to each adjacent pair of arguments

Foo is 1 + 2 + 3 + 4 + (5 and 6) + (bar taking 7) + (8 and 9) + 10 + yeah

So from the left:

1 with (2 + 3, 4, )

The most restrictive is the primary list, used in compound arithmetic expressions:

Elements in a primary list must be primary expressions. A primary expression in Rockstar is anything which yields a value without using any operators. Primaries are literal strings and numbers, variables, function calls, and language constants.

Elements in a primary list are separated by one of:

Comma ,
Ampersand &
A nacton
Next, there are expression lists. An expression list supports the same separators as the primary list, but also supports the Oxford comma separator , and Because you can’t put an Oxford comma in a primary list, this means an expression list can contain expressions that themselves contain primary lists; the Oxford comma provides an unambiguous way to separate the sub-expressions.

Expression lists are supported as arguments to compound expressions and when rocking arrays:
Example Input:
```
Rock my world
Rock my world with "a" + "b", "c", and "d" + "e" , "f", and "g" + "h" 'n' "i"
Join my world with "-"
Shout my world
(prints: abc-def-ghi)


Reverse takes a string giving -1 times a string

X is "The number "
Y is " si tsaeB eht "
X is with "of", and true and reverse taking Y
The number is 600 with 60 & 6
X is with the number
Shout X (prints: The number of the Beast is 666)
```
Example Output:
```
abc-def-ghi
The number of the Beast is 666
```

Finally, there are variable lists, used to specify the arguments when defining a function.

Because the elements in the list can only be variable names, a variable list supports all the separators used in primary and expression lists, and also the bareword ` and ` (with no commas or punctuation required).

Flow Control
Conditionals: If / Else
Consider this instruction:

Go to the store. If they have oranges, get a dozen, then get some bagels.

If the store doesn’t have oranges, should you still get bagels?

C-style languages resolve this using braces and block syntax:
if (they have oranges) {
	get a dozen
}
get some bagels

compared with:

if (they have oranges) {
	get a dozen
	get some bagels
}

Rockstar doesn’t have curly braces, because you can’t sing curly braces, so Rockstar has to use some syntactic tricks to resolve these kinds of ambiguities.

If statements can be one-liners, or conditional blocks.

One-line if
One-line if statements don’t create any block scope. However many if statements you stack on the same line, the final statement on the line either runs or it doesn’t, and then you’re done:
Example Input:
```
if true print 1 (prints: 1)

when 1 is true say 1 else say 2 (prints: 1)

if nothing is true say "yeah" otherwise say "no" (prints: no)

if false otherwise print "rock on!" (prints: rock on!)

if 1 if 2 if 3 if 4 say 4 else say 3 else say 2 else say 1 else say 0 (prints: 4)
(the one-liner is done, so the next statement will always execute)
print 1 (prints: 1)
```
Example Output:
```
1
1
no
rock on!
4
1
```

Multiline conditionals
Multiline conditionals are a little more complex, because they can create nested scopes. Here’s an example which uses some very un-Rockstar indentation to keep track of scope:
Example Input:
```
x is 6
if x > 1
	if x > 2
		if x > 3
			if x > 4
				if x > 5
					write "six,"
					end
				write "five,"
				end
			write "four,"
			end
		write "three,"
		end
	write "two,"
otherwise
	write "one,"
end
write "done!"

(writes: six,five,four,three,two,done!)

```
Example Output:
```
six,five,four,three,two,done!
```

If the condition or the else keyword is followed by a new line, it begins a new block. A block is a series of statements separated by statement separators (newlines or punctuation .!?;). The end of a block is denoted by:

An empty line (a line containing only whitespace and/or comments)
The end keyword or any of its aliases oh, yeah or baby – see below.
The else or otherwise keywords implicitly end the current block and start the alternate block for the current if.
The end of file (EOF) will implicitly close any open blocks. This isn’t Lisp, folks. The parser knows what you mean.

This is the end, oh yeah, baby
Consider this example from a C-like language:

if (x) {
	if (y) {
		if (z {
			print "this might get printed"
		}
	}
}
print "this always gets printed"

Before the final line, we need to close three blocks, so we use three closing braces – } } }.

Languages like Python that use indentation to control scope don’t have this problem: indenting creates a block, and if you drop a level of indentation, the block’s over.

Rock lyrics don’t have curly braces, and they don’t have indentation. To end a block, you can use the keyword end:
Example Input:
```
x is 4
if x is greater than 1 
if x is greater than 2
if x is greater than 3
print "this appears if x is greater than 3"
oh yeah baby
print "this is always printed"

(prints: this appears if x is greater than 3
this is always printed)
```
Example Output:
```
this appears if x is greater than 3
this is always printed
```

Singing end end end doesn’t sound very rock’n’roll, so Rockstar also supports the aliases oh, yeah and baby - because it turns out you can get away with repeating that stuff almost ad infinitum and it just sounds like song lyrics. The Corrs’ “So Young” opens with the line “yeah, yeah, yeah, yeah, yeah”, Whitesnake’s “The Deeper The Love” has a “baby baby baby”, and if you throw in the odd “oh, yeah baby, yeah yeah yeah” you can close half-a-dozen nested blocks and nobody’s going to notice except the Rockstar parser.
Example Input:
```
My heart is empty
Your world is like a fire
The hunger is like a calling
the fire is like a hurricane heartbreak

If my heart is stronger than the hunger,
If my heart is stronger than your world,
If my heart is stronger than the fire...
Scream the fire, oh, yeah baby,
Scream the fire

(prints: 190)

```
Example Output:
```
190
```

Oooooh
You can also close as many blocks as you need to by using Rockstar’s oooh keyword. This closes one block for every letter o – so oh closes one block, ooh closes two blocks, oooh closes three blocks, and so on. You can also combine oooh with other keywords, so that oooh yeah baby will close five blocks, and if there’s a blank line immediately after it, that’ll close a sixth block.
Example Input:
```
x = 5
if x > 1
if x > 2
if x > 3
if x > 4
if x > 5
print "this won't get printed because x is not greater than 5"
oooooh
print "this always gets printed"
(prints: this always gets printed)

```
Example Output:
```
this always gets printed
```

Loops: While and Until
Loops are denoted by the while and until keywords.
Example Input:
```
(writes: 01234)
X is 0. While x is less than 5
Write x
X is with 1, yeah. 

(writes: 01234)
x is 0
while x is less than 5
write x
x is with 1
end
```
Example Output:
```
0123401234
```
Example Input:
```
(writes: 12345)
x is 1
until x is more than 5
write x
x is with 1
end

(writes: 54321)
x is 5
until x is nothing
write x
x is without 1
end

(writes: 1234)
The sky is like fire
the fire is like schizoidism
My heart is nothing 
Until my heart is as high as the sky
It's with the fire
Write it, baby.
```
Example Output:
```
12345543211234
```

Nested loops create block scope: as with if statements, you must end the block with a newline, end, yeah, baby, and you can end one or more blocks using the oooh syntax:
Example Input:
```
(writes:  0.0 0.1 0.2 1.0 1.1 1.2 2.0 2.1 2.2)
x is 0
While x is less than 3
Y is 0
While y is less than 3
write " " with x, ".", y
Y is with 1 yeah
X is with 1 yeah
```
Example Output:
```
 0.0 0.1 0.2 1.0 1.1 1.2 2.0 2.1 2.2
```

To break out of a loop, use the break keyword.
Example Input:
```
(writes: 12345)
x is 1
while x is less than 10
write x
x is with 1
if x is more than 5 break
end

X is nothing
While true
If x is 5 break
Build x up
End

Shout x (prints: 5)
```
Example Output:
```
123455
```

To skip the rest of the current loop and start the next iteration, use the continue keyword:
Example Input:
```
(writes: 135)
x is 0
while x is less than 5
x is with 1
if x is 2 continue
if x is 4 continue
write x
end
```
Example Output:
```
135
```

break and continue are wildcard keywords - everything between the keyword and the next end-of-statement is ignored, so the following are all equivalent:

break it down
break it down
break my heart
break on through to the other side
Example Input:
```
The angels are true... forever is nothing,
The waves are like pain
My heart says this is the end
My loneliness is nothing
Until forever
It's with the angels. Whisper it
If my loneliness is over the waves
Break my heart like glass, oh baby, whisper my heart

(writes: 1
2
3
4
5
this is the end
)
```
Example Output:
```
1
2
3
4
5
this is the end
```

Functions
Functions are declared with a variable name followed by the takes keyword (alias wants) and a list of arguments separated by one of the following: and , & , and 'n'
Example Input:
```
Sum takes x and y
Give back x with y

Print sum taking 3, 4 (prints: 7)
Print sum taking "hello", "world" (prints: helloworld)

Success takes blood, sweat & rhythm'n'blues
Say blood with sweat, rhythm & blues, baby

Success taking 1, 2, 3 & 4 (prints: 10)
Success taking "r", "o", "c", "k" (prints: rock)
```
Example Output:
```
7
helloworld
10
rock
```

Functions can be one-liners, usually written with the giving keyword:
Example Input:
```
Sum takes x, y giving x with y
Reverse takes a string giving a string times -1

Print sum taking 18, 24 (prints: 42)
Print reverse taking "rockstar" (prints: ratskcor)
```
Example Output:
```
42
ratskcor
```

Function bodies can also be a block. Functions in Rockstar specified by the return keyword and its aliases giving, give, give back and send. A return statement can be followed by the keyword back (which has no effect but can make code more lyrical).
Example Input:
```
Polly wants a cracker
Cheese is so delicious
Put a cracker with cheese into your mouth
Give it back

Say Polly taking 5 (prints: 14)
```
Example Output:
```
14
```

Functions are called using the ‘taking’ keyword and must have at least one argument. Multiple arguments are separated with one of the following: , & , and 'n'.

Function arguments must be primary expressions:
Example Input:
```
Sum takes X and Y giving X with Y
Product takes X and Y giving X times Y

Shout sum taking product taking 2, 15, product taking 3, 4 (prints: 42)
Shout sum taking 600 & product taking sum taking 2, 4, sum taking 5, 6 (prints: 666)

Swap takes X and Y giving Y with X
Bolt takes X and Y giving X with "⚡" & Y

Shout bolt taking swap taking "C", "A", swap taking "C", "D" (prints: AC⚡DC)
```
Example Output:
```
42
666
AC⚡DC
```

he reason you can’t use operators inside function arguments is that it makes it awkward to write recursive function calls. Consider this expression

result = foo taking 1 + foo taking 2

…is that foo(1 + foo(2), or foo(1 + foo(2))? Without using parentheses to surround function arguments, the parser can’t disambiguate between the two - and since there’s no way we’re putting parentheses in Rockstar, the only solution is to disallow operators in function arguments.

This is also one of the few features where the language grammar is ambiguous, and what’s produced by the parser doesn’t necessarily match what’s executed by the interpreter. The parser is greedy and it doesn’t know anything about how many arguments a function takes (its arity), so this expression:
Example Input:
```
FuncA taking FuncB taking 1, 2, FuncB taking 3, 4
```
Example Output:
```
will produce this parse tree:

function call: FuncA  
  function call: FuncB  
    1  
    2  
    function call: FuncB  
      3  
      4
```
Thing is, FuncB doesn’t take three arguments - so rather than failing, the Rockstar interpreter only evaluates as many function arguments as the function is expecting, and any “leftover” expressions will be passed back to the outer function call, so what actually gets executed is:

call: FuncA
  args:
  1: call: FuncB:
     args:
     1: number: 1
     2: number: 2
  2: call: FuncB    }
     args:          } FuncB only expects two arguments, so
     1: number: 3   } the interpreter passes this one to the
     2: number: 4   } outermost function instead.

Functions can contain other functions, and because every function defines its own variable scope, nested functions can have the same names as the functions which enclose them. (I have no idea why you would ever want to do this, but making it impossible would have been really difficult.)
Example Input:
```
 {: data-controls="all" }
```rockstar
Johnny takes a ride
Johnny takes a ride
Johnny takes a ride
Give back "Glauten " with a ride, yeah!
Give back "Glieben " with Johnny taking a ride, yeah!	
Give back "Gunter " with Johnny taking a ride, yeah!

Say Johnny taking "Globen"
```

To declare a function with no arguments, specify it `takes null` (or aliases `nothing`, `nowhere`, `nobody`). To call a function with no arguments, use the `call` keyword, or suffix the function name with an exclamation mark:
Example Output:
```rockstar
 {: data-controls="all" }
```rockstar
Tommy takes nothing
Gina says we got to hold on 
Write it, baby

Call Tommy!
Call Tommy!
Call Tommy

(writes: we got to hold on we got to hold on we got to hold on )

### Variables, Closures and Function Scope
Rockstar uses the same scoping mechanism as JavaScript:

* Variables are global unless you declare them with `let`
* Global variables aren't *really* global unless they're declared at the top level of your program.

In this example, calling `My function` initialises two variables:

```rockstar
 {: data-controls="all" }
```rockstar
The function takes x, y
Put x into the global (create a new global variable)
Let my local be y (create a new local variable)
Print x with " " with y
End

Call the function with "a", "b" (prints: a b)
Shout the global (prints: a)
Shout my local (prints: mysterious)



```

You can declare variables inside functions, functions can contain other functions, and declaring a function inside another function creates a closure, which captures the state of any variables that existed when the function was declared.

Arrays and Collections
Arrays
Rockstar supports JavaScript-style arrays. Arrays are zero-based, and dynamically allocated when values are assigned using numeric indexes. Array elements are initialised to null; passing an out-of-range index returns mysterious:
Example Input:
```
Absolution at 0 is "Intro"
Absolution at 1 is "Apocalypse Please"
My favourite is 7
Absolution at my favourite is "Hysteria"
Absolution at 2 + 3 is "Stockholm Syndrome"

Print Absolution at 0 (prints: Intro)
Print Absolution at 7 (prints: Hysteria)
Print Absolution at 2 (prints: null)
Print Absolution at 999 (prints: mysterious)
```
Example Output:
```
Intro
Hysteria
null
mysterious
```

Array indexers can be primary values or arithmetic expressions, but you can’t use a logical expression as an array indexer.

Consider My array at 2 is 4

If not for this restriction, the parser would consume 2 is 4 as a comparison (“2 is 4 - true or false?”), return false, try to set My array at false and then blow up ‘cos there’s nothing to put in it.

Returning an array in a numeric context will return the current length of the array:
Example Input:
```
Let the array at 5150 be "Van Halen".
Print the array + 0 (prints: 5151)
Print the array at 0 (prints: null)

Rock my array with 1, 2, 3
The counter is 0
While the counter ain't my array
Print "Counting " with the counter
Build the counter up, yeah

(prints:
Counting 0
Counting 1
Counting 2)
```
Example Output:
```
5151
null
Counting 0
Counting 1
Counting 2
```

Under the hood, a Rockstar array actually contains two collections, known as the list and the hash. The list is an integer-indexed linear list of values; when you push, pop, rock and roll arrays, you’re modifying the list. If you set elements whose key is not a non-negative integer, those elements are stored in the hash.

Array indexes can be of any type, and you can mix key types within the same array. The array length only considers keys whose values are non-negative integers:
Example Input:
```
My string is "s"
My decimal is 1.2
My negative is -4
My boolean is true

The array at my string is "Sweet"
The array at my decimal is "Child"
The array at my negative is "O"
The array at my boolean is "Mine"

Print the array
(prints: [ "s": "Sweet"; 1.2: "Child"; -4: "O"; true: "Mine" ])

The array at 0 is "Whoa"
Print the array
(prints: [ "Whoa"; "s": "Sweet"; 1.2: "Child"; -4: "O"; true: "Mine" ])
```
Example Output:
```
[ "s": "Sweet"; 1.2: "Child"; -4: "O"; true: "Mine" ]
[ "Whoa"; "s": "Sweet"; 1.2: "Child"; -4: "O"; true: "Mine" ]
```

Arrays in Rockstar are one-dimensional, but they can contain other arrays:
Example Input:
```
My string is "s"
My decimal is 1.2
My negative is -4
My boolean is true

The array at my string is "Sweet"
The array at my decimal is "Child"
The array at my negative is "O"
The array at my boolean is "Mine"

Print the array
(prints: [ "s": "Sweet"; 1.2: "Child"; -4: "O"; true: "Mine" ])

The array at 0 is "Whoa"
Print the array
(prints: [ "Whoa"; "s": "Sweet"; 1.2: "Child"; -4: "O"; true: "Mine" ])
```
Example Output:
```
[ "s": "Sweet"; 1.2: "Child"; -4: "O"; true: "Mine" ]
[ "Whoa"; "s": "Sweet"; 1.2: "Child"; -4: "O"; true: "Mine" ]
```

You can use indexes to read characters from strings, and extract bits from numbers. You can also use indexers to modify individual characters in a string:
Example Input:
```
X is 43605. Index is 0
Until index is 16
If x at index write 1 else write 0
Index is with 1
end (writes: 1010101001010101)

The string is "Han Valen"
The string at 0 is "V"
The string at 4 is "H"
Shout the string (prints: Van Halen)

X is 0. Print X (prints: 0)
X at 0 is true. Print X. (prints: 1)
X at 2 is true. Print X. (prints: 5)
X at 4 is true. Print X. (prints: 21)
```
Example Output:
````
1010101001010101Van Halen
0
1
5
21
```

Trying to assign an indexed value to an existing variable which is not an array will cause an error:
Example Input:
```
The truth takes nothing giving nothing
The truth at 1 is 2
(runtime error: The truth is not an indexed variable)
```
Example Output:
```
assign:
  variable: The truth
  function():
  │ return:
  │   nüll:
  └──────────
assign:
  variable: The truth
  index:
    1
```

Looping over arrays
To loop over the list elements of an array, use for <value> in <array> If you also need the index of each element, use for <value> and <index> in <array>:
Example Input:
```
Rock ints with 9, 8, 7

For int in ints
Write int with "!"
yeah
(writes: 9!8!7!)

For int and index in ints write index with ":" with int with ", "
(writes: 0:9, 1:8, 2:7, )

The storm is silent
Rock the storm like Buenos Aires 
Rock the storm like raging thunder
Rock the storm like guitar hellfire
Rock the storm like tearin' asunder
Shatter the storm into the sky

For every star in the sky
Write the star
Yeah
(writes: ACDC)
```
Example Output:
```
9!8!7!0:9, 1:8, 2:7, ACD
```

To loop over the hash elements of an array, use for <key> of <array> - this will call the loop once for each element in the hash, setting key to the key of that element. If you need the element values as well, use for <key> and <value> of <array>:
Example Input:
```
Hash at "a" is 1
Hash at "b" is true
Hash at false is "nope"

For value and key of hash
Write key with ":" with value with " "
End
(writes: a:1 b:true false:nope )

Vixen at "vocals" is "Janet"
Vixen at "guitar" is "Jan"
Vixen at "bass" is "Share"
Vixen at "drums" is "Roxy"

For every member and role of Vixen
Shout the member with " (" with the role with ")"
Yeah

(prints:
Janet (vocals)
Jan (guitar)
Share (bass)
Roxy (drums))
```
Example Output:
```
a:1 b:true false:nope Janet (vocals)
Jan (guitar)
Share (bass)
Roxy (drums)
```

This can lead to some slightly odd-sounding lyrics:

For star in the sky
Whisper star
Yeah

so you can use the every keyword, which will prepend the to the variable names assigned inside the body of the loop:

For every star in the sky
Whisper the star
Yeah

Queue operations
Rockstar arrays can also be created and manipulated by the queue operations rock and roll. push and pop are supported for Rockstar developers who are into 80s dance music.

Pushing elements onto an array
To create a new empty array, push or rock the name of the array. To push an element onto the end of the array, push <array> <expression>.
Example Input:
```
Rock my array
Print my array (prints: [ ])
Rock my array with 123
Print my array (prints: [ 123 ])
Print my array at 0 (prints: 123)
Roll my array into the result
Print the result (prints: 123)
Print my array (prints: [ ])
```
Example Output:
```
[ ]
[ 123 ]
123
123
[ ]
```

You can rock list expressions, so you can push multiple elements onto the end of an array:
Example Input:
```
Rock Tommy "yeah!". Rock Tommy 12345. Rock Tommy true
Rock Tommy like a renegade razorblade
Rock Tommy with nothing
Rock Tommy with lies
Rock Tommy 5, 6, 7, 8
Shout Tommy + 0 (prints: 10)

While Tommy ain't nothing
Roll Tommy into the fire
Write the fire; write ", ", yeah
(writes: yeah!, 12345, true, 180, null, false, 5, 6, 7, 8, )
```
Example Output:
```
10
yeah!, 12345, true, 180, null, false, 5, 6, 7, 8, 
```

If it makes for better lyrics, you can use the with keyword - rock <array> with <expression>. Remember the with keyword is context-sensitive, so in this example:

Rock ints with 1, 2 with 3, 4, 5
          ^         ^
          |         +-- this 'with' is the binary addition operator
          |
          +------------ this 'with' is part of the array push syntax

(ints is now [ 1, 5, 4, 5 ])

This syntax is very useful for initialising strings without using string literals - see below. It also means that the following is valid Rockstar:
Example Input:
```
The Scorpions say here I am
Rock you like a hurricane

Shout it at 0
Shout it at 1
```
Example Output:
```
h
e
```

Popping elements from an array
The roll keyword will remove the first element from an array and return the element that was removed.
Example Input:
```
Rock ints with 1, 2, 3
Print roll ints (prints: 1)
Print pop ints (prints: 3)
Print roll ints (prints: 2)
Print pop ints (prints: mysterious)

The string is "abcde"
Roll the string into the letter
Print the letter (prints: a)
Print the string (prints: bcde)
```
Example Output:
```
1
3
2
mysterious
a
bcde
```

roll can be used in assignments:
Example Input:
```
Rock ints with 1, 2, 3
Let the first be roll ints
Let the second be roll ints
Let the third be roll ints
Shout the first (prints: 1)
Shout the second (prints: 2)
Shout the third (prints: 3)
```
Example Output:
```
1
2
3
```

Rockstar also supports a special roll x into y syntax for removing the first element from an array and assigning it to a variable:
Example Input:
```
Rock the list with 4, 5, 6
Roll the list into foo
Roll the list into bar
Roll the list into baz
Shout foo (prints: 4)
Shout bar (prints: 5)
Shout baz (prints: 6)
```
Example Output:
```
4
5
6
```

Array Arithmetic
As with strings, Rockstar tries hard to return something in every scenario, just in case one day somebody out there finds it useful.

Adding arrays to numbers adds the length of the array (this is the same logic that kicks in when you test an array to see if there’s anything left in it.) Adding anything else to an array will append it to the end of the array.
Example Input:
```Rock my array with 1, 2, 3
Put my array with "rock!" into Array B
Put my array with true into Array C
Put my array with null into Array D
Put my array with 5 into the number

Shout my array  (prints: [ 1, 2, 3 ])
Shout Array B (prints: [ 1, 2, 3, "rock!" ])
Shout Array C (prints: [ 1, 2, 3, true ])
Shout Array D (prints: [ 1, 2, 3, null ])
Shout the number (prints: 8)
```
Example Output:
```
[ 1, 2, 3 ]
[ 1, 2, 3, "rock!" ]
[ 1, 2, 3, true ]
[ 1, 2, 3, null ]
8
```

Subtracting arrays from arrays will return a new array, created by removing any elements in the second array from the elements of the first.

List elements are removed if the value is present
Hash elements will be removed if they match both the key and the value.
Subtracting any other value from an array returns a new array with any instances of the subtracted element removed.
Example Input:
```
Rock ABBA with "Agnetha", "Anni-Frid", "Benny" 'n' "Björn"
Rock the guys with "Björn" & "Benny"

Shout ABBA without the guys (prints: [ "Agnetha", "Anni-Frid" ])
Put ABBA without "Benny" with "Lemmy" into Abbahead
Shout ABBA (prints: [ "Agnetha", "Anni-Frid", "Benny", "Björn" ])
Shout Abbahead (prints: [ "Agnetha", "Anni-Frid", "Björn", "Lemmy" ])

Let Rush at "guitars" be "Alex"
Let Rush at "drums" be "Neil"
Let Rush at "bass" be "Geddy"
Shout Rush (prints: [ "guitars": "Alex"; "drums": "Neil"; "bass": "Geddy" ])

Let Testament at "guitars" be "Alex"
Shout Rush without Testament (prints: [ "drums": "Neil"; "bass": "Geddy" ])
```
Example Output:
```
[ "Agnetha", "Anni-Frid" ]
[ "Agnetha", "Anni-Frid", "Benny", "Björn" ]
[ "Agnetha", "Anni-Frid", "Björn", "Lemmy" ]
[ "guitars": "Alex"; "drums": "Neil"; "bass": "Geddy" ]
[ "drums": "Neil"; "bass": "Geddy" ]
```

Conversions and Mutations
Conversions and Mutations
Most of Rockstar’s built-in operations can either act in place, modifying the variable passed to them, or leave the result in a target variable and leave the source unmodified:

Modify X - acts in-place
Modify X into Y - leave X intact, store the result into Y
Modify X with Z - act in place, using optional parameter Z
Modify X into Y with Z - modify X using Z, store the result in y
Splitting Strings
To split a string in Rockstar, use the cut mutation, or aliases split and shatter.
Example Input:
```
Split "a,b,c" into the array
Shout the array (prints: [ "a", ",", "b", ",", "c" ])
Shout the array + 0 (prints: 5)

Split "a,b,c" into the array with ","
Shout the array (prints: [ "a", "b", "c" ])
Shout the array + 0 (prints: 3)

My life says heartbreak
Cut my life into pieces
Shout pieces (prints: [ "h", "e", "a", "r", "t", "b", "r", "e", "a", "k" ])
Shout pieces + 0 (prints: 10)
```
Example Output:
```
[ "a", ",", "b", ",", "c" ]
5
[ "a", "b", "c" ]
3
[ "h", "e", "a", "r", "t", "b", "r", "e", "a", "k" ]
10
```

Joining Arrays
To join an array in Rockstar, use the join mutation, or the aliases unite or gather:
Example Input:
```
Let the string be "abcde"
Split the string into the tokens
Join the tokens with ";"
Print the tokens (prints: a;b;c;d;e)

The input says hey now hey now now
Split the input into the words with " "
Unite the words into the output with "! "
Print the output with "!" (prints: hey! now! hey! now! now!)

Gather the words into the output with "-"
Print the output (prints: hey-now-hey-now-now)
```
Example Output:
```
a;b;c;d;e
hey! now! hey! now! now!
hey-now-hey-now-now
```

Type Conversions
To convert any value to a string, add it to the empty string.
Example Input:
```
Let the string be "abcde"
Split the string into the tokens
Join the tokens with ";"
Print the tokens (prints: a;b;c;d;e)

The input says hey now hey now now
Split the input into the words with " "
Unite the words into the output with "! "
Print the output with "!" (prints: hey! now! hey! now! now!)

Gather the words into the output with "-"
Print the output (prints: hey-now-hey-now-now)
```
Example Output:
```
a;b;c;d;e
hey! now! hey! now! now!
hey-now-hey-now-now
```

The built-in cast function (aka burn) will parse strings into numbers, or convert a number into a Unicode character corresponding to the number’s code point.
Example Input:
```
Let X be "123.45"
Shout X + X (prints: 123.45123.45)
Cast X with 10
Shout X + X (prints: 246.9)
Let X be "FF"
Cast X with 16 (cast using base 16)
Shout X (prints: 255)

Cast 65 into result. Shout result (prints: A)

Cast result. Shout result (prints: 65)

Cast 1046 into result. Shout result (prints: Ж)

Guitar is "1F3B8". Cast it with 16. Cast it.
Shout it. (prints: 🎸)

The string is "32"
Cast the string into the codes
Write the codes at 0 (writes: 51)
Write the codes at 1 (writes: 50)
```
Example Output:
```
123.45123.45
246.9
255
A
65
Ж
🎸
```

Arithmetic Rounding
Rounding in Rockstar is performed by the turn keyword. Turn up will round up (i.e. towards positive infinity), to the nearest integer; turn down will round down (towards negative infinity) to the nearest integer, and turn round will round to the nearest integer. Bonnie Tyler enthusiasts will be pleased to note that Rockstar accepts turn around as a valid alias.

Turn operations act in-place: they modify the variable directly, and will return the rounded value.

X is 1.2
Turn up X
Shout X (will print 2)

X is 1.2
Turn down X
Shout X (will print 1)

The radio's playing. The night has just begun.
 (initialises the radio with 7.35345)
Turn up the radio
Say the radio (will print 8)

Rounding supports variable pronouns, so you can write phrases like:

My heart is on fire. Aflame with desire.
Turn it up.
Shout it.

which will print the value 25 (obviously).


